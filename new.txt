db.js - import mongoose from "mongoose";

const connectDB = async () => {
  try {
    const conn = await mongoose.connect(process.env.MONGO_URI);
    console.log(`MongoDB Connected: ${conn.connection.host}`);
  } catch (error) {
    console.error(`Error: ${error.message}`);
    process.exit(1);
  }
};

export default connectDB;

imapConfig.js - import dotenv from "dotenv";
dotenv.config();

const imapConfig = () => ({
  imap: {
    user: process.env.GMAIL_USER,
    password: process.env.GMAIL_APP_PASSWORD,  // Make sure you use an App Password
    host: "imap.gmail.com",
    port: 993,
    tls: true,
    tlsOptions: { rejectUnauthorized: false },
    authTimeout: 3000,
  },
});

export default imapConfig;


Email.js - import mongoose from "mongoose";

const emailSchema = new mongoose.Schema({
  sender: String,
  recipient: String,
  subject: String,
  body: String,
  timestamp: Date,
  folder: { type: String, default: "INBOX" }, // âœ… Add folder field
  category: { 
    type: String, 
    enum: ["Interested", "Meeting Booked", "Not Interested", "Spam", "Out of Office", "Uncategorized"], 
    default: "Uncategorized" 
  },
});


const Email = mongoose.model("Email", emailSchema);
export default Email;

aiService.js - import { GoogleGenerativeAI } from "@google/generative-ai";
import dotenv from "dotenv";
dotenv.config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

// List of valid categories
const VALID_CATEGORIES = [
  "Interested",
  "Meeting Booked",
  "Not Interested",
  "Spam",
  "Out of Office",
];
const cache = new Map(); // Simple in-memory cache

export const categorizeEmail = async (emailText) => {
  try {
    if (cache.has(emailText)) {
      console.log("âš¡ Using Cached Category");
      return cache.get(emailText);
    }
    console.log(`ðŸ“§ Email: ${emailText.trim().substring(0, 200)}`); // Debug log
    const model = genAI.getGenerativeModel({ model: "gemini-pro" });

    const prompt = `Classify this email into one of these categories:
                        - Interested (User shows interest in the offer or product)
                        - Meeting Booked (User has scheduled or requested a meeting)
                        - Not Interested (User declines offer politely)
                        - Spam (Unwanted promotional or scam email)
                        - Out of Office (User is unavailable or on leave)
                    Reply with only the category name. 
                    Email: "${emailText.trim().substring(0, 2000)}"`;
    // const prompt = `Categorize this email into one of the following: ${VALID_CATEGORIES.join(", ")}. Return only the category name without extra explanation. Email: "${emailText.trim().substring(0, 2000)}"`;
    const result = await model.generateContent(prompt);
    const response = await result.response.text();

    // Extract valid category
    const cleanedCategory =
      VALID_CATEGORIES.find((cat) => response.includes(cat)) || "Out of Office";

    console.log(`ðŸ“Œ Categorized as: ${cleanedCategory}`);
    cache.set(emailText, cleanedCategory); // Cache the response
    return cleanedCategory;
  } catch (error) {
    console.error("âŒ Gemini API Error:");
    return "Out of Office"; // Default category on failure
  }
};

elasticService.js - import { Client } from "@elastic/elasticsearch";
import dotenv from "dotenv";
dotenv.config();

export const elasticClient = new Client({
  node: "http://localhost:9200",
  apiVersion: "7.10", // âœ… Ensure compatibility with your ES version
});

// âœ… Function to index an email
export const indexEmail = async (emailData) => {
  try {
    const response = await elasticClient.index({
      index: "emails",
      body: emailData,
    });
    console.log(`âœ… Email indexed in Elasticsearch! ID: ${response.body._id}`);
  } catch (error) {
    console.error("âŒ Elasticsearch Indexing Error:", error);
  }
};

// âœ… Function to check if an email exists
export const emailExistsInElasticsearch = async (subject, sender, timestamp) => {
  try {
    const esQuery = {
      index: "emails",
      body: {
        query: {
          bool: {
            must: [
              { match: { subject } },
              { match: { sender } },
              { range: { timestamp: { gte: timestamp } } }
            ]
          }
        }
      }
    };

    const { body } = await elasticClient.search(esQuery);
    return body.hits.total.value > 0; // âœ… Return true if email exists
  } catch (error) {
    console.error("âŒ Elasticsearch Query Error:", error);
    return false; // Assume not found in case of an error
  }
};

// âœ… Function to search emails in Elasticsearch
export const searchEmails = async (req, res) => {
  try {
    const { query } = req.query;
    const folder = req.query.folder || "INBOX";
    const account = req.query.account || "akshatnigam769@gmail.com";

    console.log("ðŸ” Search Query:", query, " | Folder:", folder, " | Account:", account);

    const esQuery = {
      index: "emails",
      body: {
        query: {
          bool: {
            must: [
              query ? { multi_match: { query, fields: ["subject", "body", "sender", "recipient"] } } : { match_all: {} },
              folder ? { match: { folder } } : {},
              account ? { match: { recipient: account } } : {}
            ].filter(Boolean),
          },
        },
      },
    };

    console.log("ðŸ“¡ Sending query to Elasticsearch:", JSON.stringify(esQuery, null, 2));

    const { body } = await elasticClient.search(esQuery);
    console.log("ðŸ”Ž Elasticsearch Response:", JSON.stringify(body, null, 2));

    res.json({ success: true, results: body.hits.hits.map((hit) => hit._source) });
  } catch (error) {
    console.error("âŒ Search API Error:", error);
    res.status(500).json({ error: "Search failed" });
  }
};

// export default elasticClient;

imapService.js - import { categorizeEmail } from "./aiService.js";
import Email from "../models/Email.js";
import imaps from "imap-simple";
import imapConfig from "../config/imapConfig.js";
import { simpleParser } from "mailparser";
import { indexEmail } from "./elasticService.js";
import { sendSlackNotification, triggerWebhook } from "./notificationService.js"; // âœ… Import notification functions

const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

const processEmails = async (connection, messages) => {
  try {
    console.log(`ðŸ“© Processing ${messages.length} new email(s)...`);

    for (const item of messages) {
      const headerPart = item.parts.find((part) => part.which === "HEADER");
      const textPart = item.parts.find((part) => part.which === "TEXT");
      const parsed = textPart ? await simpleParser(textPart.body) : { text: "No Content", html: "No Content" };
      const parsedEmail = {
        sender: headerPart?.body.from?.[0] || "Unknown",
        recipient: process.env.GMAIL_USER,
        subject: headerPart?.body.subject?.[0] || "No Subject",
        // body: textPart ? (await simpleParser(textPart.body)).text : "No Content",
        timestamp: headerPart?.body.date?.[0] ? new Date(headerPart.body.date[0]) : new Date(),
      };
      
      parsedEmail.body = parsed.html || parsed.text; // Store HTML if available, otherwise fallback to plain text
      await delay(5000); // Prevent rate limiting
      parsedEmail.category = await categorizeEmail(parsedEmail.body);

      // âœ… Set folder name as the category name
      parsedEmail.folder = parsedEmail.category;

      await Email.create(parsedEmail);
      await indexEmail(parsedEmail);

      // âœ… Send Slack notification & webhook trigger if category is "Interested"
      if (parsedEmail.category === "Interested") {
        const message = `ðŸš€ *New Interested Email!*  
        *From:* ${parsedEmail.sender}  
        *Subject:* ${parsedEmail.subject}  
        *Body:* ${parsedEmail.body.substring(0, 200)}...`;

        await sendSlackNotification(message);
        await triggerWebhook(parsedEmail.body);
      }
    }

    console.log("âœ… Emails Categorized & Stored Successfully!");
  } catch (error) {
    console.error("âŒ Error processing emails:", error);
  }
};



// âœ… Function to fetch past 30 days of emails
export const fetchEmails = async () => {
  try {
    console.log("ðŸ”„ Connecting to Gmail IMAP...");
    const connection = await imaps.connect(imapConfig());
    console.log("âœ… IMAP Connection Established!");

    await connection.openBox("INBOX");
    console.log("ðŸ“¥ Inbox Opened!");

    const sinceDate = new Date();
    sinceDate.setDate(sinceDate.getDate() - 30); // Fetch last 30 days
    const searchCriteria = [["SINCE", sinceDate.toISOString().split("T")[0]]];

    const fetchOptions = { bodies: ["HEADER", "TEXT"], struct: true };
    const messages = await connection.search(searchCriteria, fetchOptions);

    await processEmails(connection, messages);
    connection.end();
  } catch (error) {
    console.error("âŒ Error fetching emails:", error);
    throw new Error(error.message || "Failed to fetch emails.");
  }
};

// âœ… Real-time email synchronization using IMAP IDLE
export const listenForNewEmails = async () => {
  try {
    console.log("ðŸ”„ Connecting to Gmail IMAP for real-time updates...");
    const connection = await imaps.connect(imapConfig());
    await connection.openBox("INBOX");
    console.log("âœ… Listening for new emails using IMAP IDLE...");

    connection.on("mail", async (numNewMsgs) => {
      console.log(`ðŸ“© New Email(s) Detected! (${numNewMsgs})`);
      const searchCriteria = ["NEW"];
      const fetchOptions = { bodies: ["HEADER", "TEXT"], struct: true };
      const messages = await connection.search(searchCriteria, fetchOptions);

      await processEmails(connection, messages);
    });

    connection.on("error", (err) => {
      console.error("âŒ IMAP Connection Error:", err);
      setTimeout(listenForNewEmails, 5000); // Restart on error
    });

  } catch (error) {
    console.error("âŒ Error in IMAP IDLE Mode:", error);
    setTimeout(listenForNewEmails, 5000); // Retry after 5 sec on failure
  }
};

notificationService.js - import axios from "axios";
import dotenv from "dotenv";
dotenv.config();

const SLACK_WEBHOOK_URL = process.env.SLACK_WEBHOOK_URL; // Store in .env file
const WEBHOOK_URL = process.env.WEBHOOK_URL; // Replace with your Webhook.site URL

export const sendSlackNotification = async (message) => {
  try {
    await axios.post(SLACK_WEBHOOK_URL, { text: message });
    console.log("âœ… Slack Notification Sent!");
  } catch (error) {
    console.error("âŒ Error sending Slack notification:", error);
  }
};

export const triggerWebhook = async (data) => {
  try {
    await axios.post(WEBHOOK_URL, data);
    console.log("âœ… Webhook Triggered Successfully!");
  } catch (error) {
    console.error("âŒ Error triggering webhook:", error);
  }
};



server.js - import express from "express";
import dotenv from "dotenv";
import connectDB from "./config/db.js";
import emailRoutes from "./routes/emailRoutes.js"; // âœ… Ensure correct import
// import cors from "cors";
// âœ… Import the search function


dotenv.config();
connectDB();
process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";

const app = express();
// app.use(cors()); 
// âœ… Allow requests from frontend
app.use(express.json());  // âœ… Ensure JSON parsing
app.use("/emails", emailRoutes); // âœ… Hook up email routes

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
  console.log(`ðŸš€ Server running on port ${PORT}`);
});


package.json - {
  "name": "email-onebox",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "start": "node server.js",
    "dev": "backEnd/server.js",
    "build": "echo 'No build step needed'"
  },
  "type": "module",
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "@elastic/elasticsearch": "^7.17.14",
    "@google/generative-ai": "^0.22.0",
    "axios": "^1.7.9",
    "body-parser": "^1.20.3",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "google-auth-library": "^9.15.1",
    "googleapis": "^144.0.0",
    "imap": "^0.8.19",
    "imap-simple": "^5.1.0",
    "mailparser": "^3.7.2",
    "mongodb": "^6.13.1",
    "mongoose": "^8.10.1"
  },
  "devDependencies": {
    "nodemon": "^3.1.9"
  }
}